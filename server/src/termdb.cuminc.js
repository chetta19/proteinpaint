const path = require('path')
const get_rows = require('./termdb.sql').get_rows
const write_file = require('./utils').write_file
const fs = require('fs')
const lines2R = require('./lines2R')
const serverconfig = require('./serverconfig')

/*********** EXPORT
get_incidence()
runCumincR
*/

export async function get_incidence(q, ds) {
	try {
		if (!ds.cohort) throw 'cohort missing from ds'
		q.ds = ds
		const results = get_rows(q)
		const byChartSeries = {}
		for (const d of results.lst) {
			// do not include data when years_to_event < 0
			if (d.val1 < 0) continue
			// if no applicable term0 or term2, the d.key0/d.key2 is just a placeholder empty string,
			// see the comments in the get_rows() function for more details
			if (!(d.key0 in byChartSeries)) byChartSeries[d.key0] = []
			byChartSeries[d.key0].push({ time: d.val1, event: d.key1, series: d.key2 })
		}
		const bins = q.term2_id && results.CTE2.bins ? results.CTE2.bins : []
		const final_data = {
			keys: ['chartId', 'seriesId', 'time', 'cuminc', 'low', 'high'],
			case: [],
			refs: { bins }
		}
		const promises = []
		for (const chartId in byChartSeries) {
			const data = byChartSeries[chartId]
			if (!data.length) continue

			// skip series that do not meet sample size and event count thresholds
			// compute sample sizes and event counts
			const series2size = new Map()
			for (const sample of data) {
				const size = series2size.get(sample.series)
				if (size) {
					size.samplesize++
					if (sample.event) size.eventcnt++
					series2size.set(sample.series, size)
				} else {
					series2size.set(sample.series, { samplesize: 1, eventcnt: sample.event ? 1 : 0 })
				}
			}

			// flag series that do not meet thresholds
			const toSkip = new Set()
			for (const [series, size] of series2size) {
				if (size.samplesize < q.minSampleSize || size.eventcnt < q.minEventCnt) {
					toSkip.add(series)
				}
			}

			// skip any flagged series
			let fdata
			if (toSkip.size > 0) {
				// series need to be skipped
				// remove the series from the data
				fdata = data.filter(sample => !toSkip.has(sample.series))
				// store the skipped series
				if (!final_data.skippedSeries) final_data.skippedSeries = {}
				final_data.skippedSeries[chartId] = [...toSkip]
				if (fdata.length === 0) {
					// all series in this chart have been skipped
					// therefore this chart will be skipped
					if (!final_data.skippedCharts) final_data.skippedCharts = []
					final_data.skippedCharts.push(chartId)
					continue
				}
			} else {
				// no series need to be skipped
				fdata = data
			}

			/* fdata[] is an array of elements, each element is a sample with following keys:
			.time: float
			.event: 0/1
			.series: str // blank string if just one series, non-emtpy string for multiple series
			*/

			const serieses = new Set(data.map(x => x.series))

			promises.push(runCumincR(chartId, fdata, serieses, final_data, q.term1_q.minYearsToEvent))
		}
		await Promise.all(promises)
		return final_data
	} catch (e) {
		if (e.stack) console.log(e.stack)
		return { error: e.message || e }
	}
}

/* run cumulative incidence analysis in R
function has no returns; R analysis result are collected into "final_data{}"

chartId: a string, can be empty
fdata[]: see above
serieses: a set of strings, can contain just one empty string if just one series
final_data{}
	.case[]
	.tests{}
minYearsToEvent
*/
export async function runCumincR(chartId, fdata, serieses, final_data, minYearsToEvent) {
	const datafile = path.join(serverconfig.cachedir, Math.random().toString() + '.json')
	await write_file(datafile, JSON.stringify(fdata))
	const Routput = await lines2R(path.join(serverconfig.binpath, 'utils/cuminc.R'), [], [datafile])
	const ci_data = JSON.parse(Routput[0])

	// for chart with a single series, R will convert the series ID from '' to '1', so convert back to empty string
	if (serieses.size == 1 && serieses.has('')) {
		ci_data.estimates[''] = ci_data.estimates['1']
		delete ci_data.estimates['1']
		if (Object.keys(ci_data.estimates).length != 1) throw 'unexpected number of series in chart'
	}

	// store cumulative incidence estimates
	for (const seriesId in ci_data.estimates) {
		const series = ci_data.estimates[seriesId]
		// the first time point generated by cuminc() in R is always time 0
		// replace this time with 'q.term1_q.minYearsToEvent'
		series[0].time = minYearsToEvent
		for (let i = 0; i < series.length; i++) {
			final_data.case.push([chartId, seriesId, series[i].time, series[i].est, series[i].low, series[i].up])
		}
	}

	// store results of statistical tests
	if (ci_data.tests) {
		if (!final_data.tests) final_data.tests = {}
		final_data.tests[chartId] = ci_data.tests
	}

	// delete the input data file
	fs.unlink(datafile, () => {})
}
