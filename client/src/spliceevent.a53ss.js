export function findalternativeSSevents(lst) {
	/*
	lst[]  list of junctions

	as generated by mapjunctiontoexons()

	.matchisoform[]
	.exonleft
	.exonright
	.exonleftin
	.exonrightin
	.intronleft
	.intronright
	.leftout
	.rightout

	*/

	const events = []

	for (const j of lst) {
		// tell if this junction match a known intron by matchisoform[]
		let iscanonical = false
		for (const m of j.matchisoform) {
			if (Math.abs(m.leftexonidx - m.rightexonidx) == 1) {
				iscanonical = true
				break
			}
		}
		if (iscanonical) {
			continue
		}

		for (const leftpoint of j.exonleft) {
			const gm = leftpoint.gm
			const forward = gm.strand == '+'
			for (const rightpoint of j.exonrightin) {
				if (rightpoint.gm.isoform == gm.isoform && rightpoint.exonidx == leftpoint.exonidx + (forward ? 1 : -1)) {
					const e = {
						gm: gm,
						junctionB: j,
						altinexon: true,
						sitedist: Math.abs(j.stop - gm.exon[rightpoint.exonidx][0])
					}
					if (forward) {
						e.a3ss = true
						e.exon5idx = leftpoint.exonidx
					} else {
						e.a5ss = true
						e.exon5idx = rightpoint.exonidx
					}
					events.push(e)
				}
			}
			for (const rightpoint of j.intronright) {
				if (rightpoint.gm.isoform == gm.isoform && rightpoint.intronidx == leftpoint.exonidx - (forward ? 0 : 1)) {
					const e = {
						gm: gm,
						junctionB: j,
						altinintron: true,
						sitedist: Math.abs(j.stop - gm.intron[rightpoint.intronidx][1])
					}
					if (forward) {
						e.a3ss = true
						e.exon5idx = leftpoint.exonidx
					} else {
						e.a5ss = true
						e.exon5idx = rightpoint.intronidx
					}
					events.push(e)
				}
			}
		}

		for (const right of j.exonright) {
			const gm = right.gm
			const forward = gm.strand == '+'
			for (const left of j.exonleftin) {
				if (left.gm.isoform == gm.isoform && left.exonidx == right.exonidx - (forward ? 1 : -1)) {
					const e = {
						gm: gm,
						junctionB: j,
						altinexon: true,
						sitedist: Math.abs(j.start - gm.exon[left.exonidx][1])
					}
					if (forward) {
						e.a5ss = true
						e.exon5idx = left.exonidx
					} else {
						e.a3ss = true
						e.exon5idx = right.exonidx
					}
					events.push(e)
				}
			}
			for (const left of j.intronleft) {
				if (left.gm.isoform == gm.isoform && left.intronidx == right.exonidx - (forward ? 1 : 0)) {
					const e = {
						gm: gm,
						junctionB: j,
						altinintron: true,
						sitedist: Math.abs(j.start - (gm.intron[left.intronidx][0] - 1))
					}
					if (forward) {
						e.a5ss = true
						e.exon5idx = left.intronidx
					} else {
						e.a3ss = true
						e.exon5idx = right.exonidx
					}
					events.push(e)
				}
			}
		}
	}

	// find canonical junction for each event
	for (const e of events) {
		// canonical junction must span intron e.exon5idx
		const intron = e.gm.intron[e.exon5idx]
		let jA
		for (const j of lst) {
			if (j.start == intron[0] - 1 && j.stop == intron[1]) {
				jA = j
				break
			}
		}
		if (jA) {
			e.junctionA = jA
			e.percentage = Math.ceil((100 * e.junctionB.data[0].v) / (e.junctionB.data[0].v + jA.data[0].v))
		} else {
			e.percentage = 100
		}
	}
	return events
}
