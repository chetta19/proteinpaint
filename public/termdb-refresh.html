<!DOCTYPE html>
<html lang="en" style="margin:0px;width:100%;height:100%">
<head>
	 <meta charset="utf-8">
	 <title>Termdb Refresh</title>
	 <style>
	 	body {
	 		font-family: Menlo, Monospace, Consolas, Arial, sans-serif;
	 	}
	 </style>
	 <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js" integrity="sha512-RJJ1NNC88QhN7dwpCY8rm/6OxI+YdQP48DrLGe/eSAd+n+s1PXwQkkpzzAgoJe4cZFW2GALQoxox61gSY2yQfg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body style="margin:0px;width:100%;height:100%">

<noscript>This page requires JavaScript. Please enable it in your browser settings.</noscript>

<div id=aaa style="margin:10px"></div>

<script>
const params = getParams()
if (!params.route) {
	alert(`Please specify a 'route=' parameter value in the URL.`)
} else {
	showForm()
}

async function showForm() {
	const app = {
		dom: {
			holder: d3.select('#aaa').style('margin', '20px').style('padding', '10px')
		}
	}
	try {
		const data = await fetch(params.route).then(r=>r.json())
		const div = app.dom.holder
		div.append('h1').text(`${data.label} database update`)

		showExtractOption(div, app)
		
		div.append('div')
			.style('margin', '20px 0')
			.html('(May skip the extraction above and directly paste tab-delimited data below:)')

		div.append('div').html(`NOTE: Do not include a header row!`)

		const subdivs = div.selectAll('.refresh-subdiv')
			.data(data.files)
			.enter()
			.append('div')
			.attr('class', 'refresh-subdiv')
			.style('text-align', 'left')
			.style('padding', '15px')

		subdivs.append('div')
			.style('display', 'inline-block')
			.style('width', '120px')
			.style('margin', '10px')
			.style('vertical-align', 'top')
			.text(name=>name)

		app.dom.textareas = subdivs.append('textarea')
			.attr('placeholder', 
				d => d == 'annotations' 
					? `sample\tterm_id\tvalue` 
					: d == 'survival' 
					? `sample\tterm_id\ttte\texit_code`
					: `id\tname\tparent_id\tjsondata\tchild_order\ttype\tisleaf` 
			)
			.style('width', '650px')
			.style('height', '300px')
			.style('margin', '10px')
			.style('white-space', 'nowrap')

		div.append('button')
			.style('margin', '10px')
			.text('Submit')
			.on('click', ()=>{
				const tsv = {}
				subdivs.each(function(name) {
					const content = d3.select(this).select('textarea').property('value')
					if (content) tsv[name] = content
				})
				try {
					if (!Object.keys(tsv).length) {
						throw 'No data to submit.'
					}

					const opts = {
						method: 'POST',
						headers: {
							'content-type': 'application/json'
						},
						body: JSON.stringify(tsv)
					}
					fetch(params.route, opts)
						.then(r=>r.json())
						.then(r => {
							if (r.error) throw r.error
							if (r.status != 'ok') throw 'server response not ok'
						})
						.catch(e => {throw e})
				} catch(e) {
					alert(e)
				}
			})

	} catch(e) {
		alert(e.error || e)
	}
}

function getParams() {
  const params={}
  if (!window.location.search.length) return params
  window.location.search.substr(1).split("&").forEach(kv=>{
    const [key,value] = kv.split("=")
    params[key] = value
  })
  return params
}

function showExtractOption(div, app) {
	const filediv = div
			.append('div')
			.style('margin', '10px')

	filediv.append('label')
		.html('Option to extract data from a study json file: ')
		
	const fileInput = filediv.append('input')
		.attr('type', 'file')
		.on('change', ()=>{
			const reader = new FileReader()
			const file = d3.event.target.files[0]
			if (file.size == 0) {
				alert(`empty file='${file.name}'`)
				return
			}
			reader.onload = async event => {
				try {
					const study = JSON.parse(event.target.result)
					const data = await hmjsonETL(study); console.log(52, data)
					
					const termsTSV = []
					for(const t of data.terms) {
						const isleaf = 'isleaf' in t ? t.isleaf : 1
						const parent_id = 'parent_id' in t ? t.parent_id : ''
						const jsondata = JSON.stringify({type: t.type, values: t.values, isleaf})
						termsTSV.push(`${t.id}\t${t.name}\t${parent_id}\t${jsondata}\t\t${t.type}\t${isleaf}`)
					}
					app.dom.textareas.filter(d=>d=='terms').text(termsTSV.join('\n'))

					const annoTSV = []
					for(const sample in data.annotations) {
						const anno = data.annotations[sample]
						for(const term_id in anno) {
							if (term_id == 'sample') continue
							annoTSV.push(`${sample}\t${term_id}\t${anno[term_id]}`)
						}
					}
					app.dom.textareas.filter(d=>d=='annotations').text(annoTSV.join('\n'))
				} catch(e) {
					throw e
				}
			}
			reader.onerror = function() {
				alert('Error reading file ' + file.name)
			}
			reader.readAsText(file, 'utf8')
		})
}

async function hmjsonETL(study) {
	const { heatmapJSON, annotations } = study
	if (annotations) {
		if (annotations.inputFormat !== 'metadataTsv') {
			const message = `annotations.inputFormat: '${annotations.inputFormat}' is not supported`
			alert(message)
			throw message
		}

		for (const key in annotations.files) {
			const body = JSON.stringify({file: annotations.files[key]})
			const initOpts = {
				method: 'POST',
				headers: {
					'content-type': 'application/json'
				},
				body
			}
			const data = await fetch('/textfile', initOpts).then(r => r.json())
			heatmapJSON.metadata = addMetadataFromTsv(heatmapJSON, data.text)
		}
	}
	const terms = getTerms(heatmapJSON.metadata)
	return { terms, annotations: heatmapJSON.sampleannotation}
}

function getTerms(metadata) { console.log(193)
	const terms = []
	for (const t of metadata) {
		const term = {
			id: t.key || t.name || t.label,
			name: t.label
		}

		const vKeys = Object.keys(t.values)
		const numericVals = vKeys.filter(isNumeric)
		t.hasOnlyNumericVals = vKeys.length == numericVals.length
		
		if (t.type) {
			term.type = t.type
		} else if (t.hasOnlyNumericVals) {
			t.values = Object.values(t.values).filter(v=>v.uncomputable)
			if (!t.values) delete t.values
			term.type = 'float'
		} else { if (t.label=='Age') console.log(t)
			term.type = 'categorical'
		}

		if (t.values && ((t.type != 'float' && t.type != 'integer' ) || t.values.length)) {
			term.values = {}
			for (const key in t.values) {
				term.values[key] = { key, label: key }
				if (t.values[key]) term.values[key].color = t.values[key]
			}
		}

		terms.push(term)
	}
	return terms
}

function isNumeric(n) {
	return !isNaN(parseFloat(n)) && isFinite(n)
}

function addMetadataFromTsv(hm, data) {
	const sampleannotation = {}
	const metadata = {}
	const metaOrder = []
	const groups = {}
	const colorFxn = () => '#ccc' //scaleOrdinal(schemeCategory20)
	let header

	const metakeys = {}
	if (hm.metadata)
		hm.metadata.forEach(grp => {
			metakeys[grp.name] = grp.key
		})
	const rows = typeof data == 'string' ? annoFromTsv(data) : data
	rows.forEach(a => {
		if (!a) return
		if (a.group) {
			a.genegrpname = a.group
			if (!metakeys[a.group]) metakeys[a.group] = a.group
		}
		const key = metakeys[a.term] ? metakeys[a.term] : a.term
		a.gene = a.term
		a.anno = a.term

		const m = Array.isArray(hm.metadata) && hm.metadata.find(m => m.key == a.term)
		if (!metadata[a.term]) {
			metaOrder.push(a.term)
			metadata[a.term] = {
				name: a.term,
				setkey: a.group ? metakeys[a.group] : null,
				label: a.term,
				key: key,
				values: {},
				renderAs: a.renderAs,
				colorRange: a.colorRange ? a.colorRange.split(',') : null,
				barh: a.barh,
				sortorder: 'sortorder' in a && !isNaN(a.sortorder) ? +a.sortorder : 0
			}
		}

		if (!groups[a.group]) {
			groups[a.group] = {}
		}
		if (metadata[a.term].renderAs || !metadata[a.term].values[a.value]) {
			if (a.color) {
				metadata[a.term].values[a.value] = a.color
				groups[a.group][a.value] = a.color
			} else if (groups[a.group][a.value]) {
				metadata[a.term].values[a.value] = groups[a.group][a.value]
			} else if (metadata[a.term]) {
				metadata[a.term].values[a.value] = ''
				groups[a.group][a.value] = ''
			}

			if (a.legendorder) {
				if (!metadata[a.term].legendorder) metadata[a.term].legendorder = {}
				metadata[a.term].legendorder[a.value] = +a.legendorder
			}
		}
		a.fill = metadata[a.term].values[a.value] ? metadata[a.term].values[a.value] : ''

		if (!sampleannotation[a.sample]) sampleannotation[a.sample] = {}
		sampleannotation[a.sample][a.term] = a.value
	})

	hm.sampleannotation = sampleannotation

	return Object.values(metadata).sort((a, b) => {
		return (a.sortorder || b.sortorder) && a.sortorder != b.sortorder
			? a.sortorder - b.sortorder
			: metaOrder.indexOf(a.key) - metaOrder.indexOf(b.key)
	})
}

function annoFromTsv(text) {
	return text.split('\n').reduce((data, line) => {
		if (!line) return data
		if (!data.header) data.header = line.split('\t')
		else {
			const vals = line.split('\t')
			const a = {}
			data.header.map((k, j) => {
				if (vals[j] /*|| k!='color'*/) a[k] = vals[j]
				if (k == 'sortorder' && !isNaN(a[k])) {
					// isNaN() will coerce string values to numeric where applicable
					// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN
					a[k] = +a[k]
				}
			})
			data.push(a)
		}
		return data
	}, [])
}
</script>

</body>
</html>
