import * as rx from '../common/rx.core'
import * as client from '../client'
import { appInit } from '../termdb/app'

/*

************** opts{} of constructor
.holder
.genome
.dslabel
.placeholder
.callback( data )
	.term{} // optional
	.q{}


************** this.api, exposed!!
.main( data )
	.term{} // optional
	.q{}
	.disable_terms
.showTree()


************** instance private properties
.opts{}
.term{}
.q{}
.disable_terms[]


************** introducing the atypical API
-- this.api{} is self-made, not generated by getComponentApi
-- api not registered in caller.components{}, not in the notify-cycle
-- no bus
-- upon init, termsetting constructor does not accept initial value of term/q
   term/q/disable_terms will only be set/updated through api.main()
-- termsetting opts.callback() will send caller updated term/q via user fiddling


************** explain behavior here:

*/

class TermSetting {
	constructor(opts) {
		this.opts = this.validateOpts(opts)
		this.genome = opts.genome
		this.dslabel = opts.dslabel
		this.placeholder = opts.placeholder || 'Select term&nbsp;'

		this.dom = {
			holder: opts.holder,
			tip: new client.Menu({ padding: '0px' })
		}
		setInteractivity(this)
		setRenderers(this)
		this.initUI()

		// this api will be frozen and returned by termsettingInit()
		this.api = {
			main: async (data = {}) => {
				this.validateMainData(data)
				// term is read-only if it comes from state, let it remain read-only
				this.term = data.term
				this.q = rx.fromJson(rx.toJson(data.q)) // q{} will be altered here and must not be read-only
				this.disable_terms = data.disable_terms
				this.updateUI()
			},
			showTree: this.showTree
		}
	}

	validateOpts(o) {
		if (!o.holder) throw '.holder missing'
		if (!o.genome) throw '.genome missing'
		if (!o.dslabel) throw '.dslabel missing'
		if (typeof o.callback != 'function') throw '.callback() is not a function'
		return o
	}
	validateMainData(d) {
		if (d.term) {
			// term is optional
			if (!d.term.id) throw 'data.term.id missing'
			if (!d.term.name) throw 'data.term.name missing'
		}
		if (!d.q) d.q = {}
		if (typeof d.q != 'object') throw 'data.q{} is not object'
		if (d.disable_terms) {
			if (!Array.isArray(d.disable_terms)) throw 'data.disable_terms[] is not array'
		}
	}
}

exports.termsettingInit = rx.getInitFxn(TermSetting)

function setRenderers(self) {
	self.initUI = () => {
		// toggle the display of pilldiv and nopilldiv with availability of this.term
		self.dom.nopilldiv = self.dom.holder
			.append('div')
			.style('cursor', 'pointer')
			.on('click', self.showTree)
		self.dom.pilldiv = self.dom.holder
			.append('div')
			.attr('class', 'ts_pill')
			.style('cursor', 'pointer')
			.on('click', self.showMenu)

		// nopilldiv - placeholder label
		self.dom.nopilldiv
			.append('div')
			.html(self.placeholder)
			.style('padding', '3px 6px 3px 6px')
			.style('display', 'inline-block')

		// nopilldiv - plus button
		self.dom.nopilldiv
			.append('div')
			.attr('class', 'sja_filter_tag_btn add_term_btn')
			.style('padding', '3px 6px 3px 6px')
			.style('display', 'inline-block')
			.style('border-radius', '6px')
			.style('background-color', '#4888BF')
			.text('+')

		// blue pill, TODO add the multiple segments of a pill
		self.dom.pill_termname = self.dom.pilldiv
			.append('div')
			.style('display', 'inline-block')
			.attr('class', 'sja_filter_tag_btn ts_name_btn')
			.style('padding', '3px 6px 3px 6px')
			.style('border-radius', '6px')
			.style('background', '#4888BF')
			.style('color', 'white')
		self.dom.pill_settingSummary = self.dom.pilldiv // this may be hidden
			.append('div')
			.style('display', 'inline-block')
			.attr('class', 'sja_filter_tag_btn ts_summnary_btn')
			.style('padding', '3px 6px 3px 6px')
			.style('border-radius', '0 6px 6px 0')
			.style('background', '#674EA7')
			.style('color', 'white')
	}

	self.updateUI = () => {
		if (!self.term) {
			// no term
			self.dom.nopilldiv.style('display', 'block')
			self.dom.pilldiv.style('display', 'none')
			return
		}
		// has term
		const grpsetting_flag = self.q && self.q.groupsetting && self.q.groupsetting.inuse
		const grp_summary_text =
			self.term.groupsetting &&
			self.term.groupsetting.lst &&
			self.q.groupsetting &&
			self.q.groupsetting.predefined_groupset_idx
				? self.term.groupsetting.lst[self.q.groupsetting.predefined_groupset_idx].name
				: self.q.groupsetting && self.q.groupsetting.customset
				? 'Divided into ' + self.q.groupsetting.customset.groups.length + ' groups'
				: ''

		self.dom.nopilldiv.style('display', 'none')
		self.dom.pilldiv.style('display', 'block')
		self.dom.pill_termname.style('border-radius', grpsetting_flag ? '6px 0 0 6px' : '6px').html(self.term.name) // TODO trim long string
		self.dom.pill_settingSummary.style('display', grpsetting_flag ? 'inline-block' : 'none')
		self.dom.pill_settingSummary.html(grp_summary_text)
	}
}

function setInteractivity(self) {
	self.removeTerm = () => {
		self.opts.callback(null)
	}

	self.showTree = () => {
		self.dom.tip.clear().showunder(self.dom.holder.node())
		appInit(null, {
			holder: self.dom.tip.d,
			state: {
				genome: self.genome,
				dslabel: self.dslabel
			},
			tree: {
				click_term: term => {
					self.dom.tip.hide()
					const data = { id: term.id, term, q: {} }
					termsetting_fill_q(data.q, term)
					self.opts.callback(data)
				},
				disable_terms: self.disable_terms
			}
		})
	}

	self.showMenu = () => {
		self.dom.tip.clear().showunder(self.dom.holder.node())

		const term_option_div = self.dom.tip.d.append('div')
		const term_edit_div = self.dom.tip.d.append('div').style('text-align', 'center')

		const optsFxn = self.term.iscategorical
			? self.showCatOpts
			: self.term.isfloat || self.term.isinteger
			? self.showNumOpts
			: self.term.iscondition
			? self.showConditionOpts
			: null

		term_option_div
			.append('div')
			.style('margin', '5px 2px')
			.style('text-align', 'center')

		optsFxn(term_option_div)

		term_edit_div
			.append('div')
			.attr('class', 'replace_btn sja_filter_tag_btn')
			.style('display', self.opts.disable_ReplaceRemove ? 'none' : 'inline-block')
			.style('border-radius', '10px')
			.style('background-color', '#74b9ff')
			.style('padding', '7px 6px')
			.style('margin', '5px')
			.style('text-align', 'center')
			.style('font-size', '.8em')
			.style('text-transform', 'uppercase')
			.text('Replace')
			.on('click', () => {
				self.dom.tip.clear()
				self.showTree()
			})
		term_edit_div
			.append('div')
			.attr('class', 'remove_btn sja_filter_tag_btn')
			.style('display', self.opts.disable_ReplaceRemove ? 'none' : 'inline-block')
			.style('border-radius', '10px')
			.style('background-color', '#ff7675')
			.style('padding', '7px 6px')
			.style('margin', '5px')
			.style('text-align', 'center')
			.style('font-size', '.8em')
			.style('text-transform', 'uppercase')
			.text('Remove')
			.on('click', () => {
				self.dom.tip.hide()
				self.removeTerm()
			})
	}

	self.showCatOpts = async function(div) {
		const grpsetting_flag = self.q && self.q.groupsetting && self.q.groupsetting.inuse
		const predefined_group_name =
			self.term.groupsetting &&
			self.term.groupsetting.lst &&
			self.q.groupsetting &&
			self.q.groupsetting.predefined_groupset_idx
				? self.term.groupsetting.lst[self.q.groupsetting.predefined_groupset_idx].name
				: ''

		const active_group_info_div = div.append('div').style('margin', '10px')

		// if using predfined groupset, display name
		active_group_info_div
			.append('div')
			.style('display', predefined_group_name ? 'block' : 'none')
			.html('Using ' + predefined_group_name)

		//display groups and categories assigned to that group
		if (grpsetting_flag) {
			const groupset = self.q.groupsetting.predefined_groupset_idx
				? self.term.groupsetting.lst[self.q.groupsetting.predefined_groupset_idx]
				: self.q.groupsetting.customset || undefined

			const group_table = active_group_info_div.append('table').style('font-size', '.8em')

			for (const [i, g] of groupset.groups.entries()) {
				const group_tr = group_table.append('tr')

				//group name
				group_tr
					.append('td')
					.style('font-weight', 'bold')
					.style('vertical-align', 'top')
					.html(g.name || 'Group ' + (i + 1) + ':')

				const values_td = group_tr.append('td')

				for (const v of g.values) {
					values_td.append('div').html(self.term.values[v.key].label)
				}
			}

			//redevide groups btn
			div
				.append('div')
				.attr('class', 'group_btn sja_filter_tag_btn')
				.style('display', 'block')
				.style('padding', '7px 6px')
				.style('margin', '5px')
				.style('text-align', 'center')
				.style('font-size', '.8em')
				.style('border-radius', '10px')
				.style('background-color', '#eee')
				.style('color', '#000')
				.html('Redivide groups')
				.on('click', () => {
					const valGrp = self.grpSet2valGrp(groupset)
					self.regroupMenu(groupset.groups.length, valGrp)
				})
		}

		const default_btn_txt =
			(!grpsetting_flag ? 'Using' : 'Use') +
			' default category' +
			(self.term.values ? '(n=' + Object.keys(self.term.values).length + ')' : '')

		// default overlay btn - devide to n groups (n=total)
		div
			.append('div')
			.attr('class', 'group_btn sja_filter_tag_btn')
			.style('display', 'block')
			.style('padding', '7px 6px')
			.style('margin', '5px')
			.style('text-align', 'center')
			.style('font-size', '.8em')
			.style('border-radius', '10px')
			.style('background-color', !grpsetting_flag ? '#f8f8f8' : '#eee')
			.style('color', '#000')
			.style('pointer-events', !grpsetting_flag ? 'none' : 'auto')
			.text(default_btn_txt)
			.on('click', () => {
				self.q.groupsetting.inuse = false
				self.dom.tip.hide()
				self.opts.callback({
					id: self.term.id,
					term: self.term,
					q: self.q
				})
			})

		//show button/s for default groups
		if (self.term.groupsetting && self.term.groupsetting.lst) {
			for (const group of self.term.groupsetting.lst) {
				div
					.append('div')
					.attr('class', 'group_btn sja_filter_tag_btn')
					.style('display', 'block')
					.style('padding', '7px 6px')
					.style('margin', '5px')
					.style('text-align', 'center')
					.style('font-size', '.8em')
					.style('border-radius', '10px')
					.style('background-color', '#eee')
					.style('color', '#000')
					.html('Use <b>' + group.name + '</b>')
			}
		}

		// devide to grpups btn
		div
			.append('div')
			.attr('class', 'group_btn sja_filter_tag_btn')
			.style(
				'display',
				(self.term.groupsetting && self.term.groupsetting.disabled) || grpsetting_flag ? 'none' : 'block'
			)
			.style('padding', '7px 6px')
			.style('margin', '5px')
			.style('text-align', 'center')
			.style('font-size', '.8em')
			.style('border-radius', '10px')
			.style('background-color', '#eee')
			.style('color', '#000')
			.html('Divide <b>' + self.term.name + '</b> to groups')
			.on('click', () => {
				self.regroupMenu()
			})
	}

	self.regroupMenu = function(grp_count, temp_cat_grps) {
		//start with default 2 groups, extra groups can be added by user
		const default_grp_count = grp_count || 2
		const cat_grps = temp_cat_grps || JSON.parse(JSON.stringify(self.term.values))

		//initiate empty customset
		const customset = { groups: [] }
		Array(default_grp_count)
			.fill()
			.map(() => customset.groups.push({ values: [] }))

		self.dom.tip.clear().showunder(self.dom.holder.node())

		const regroup_div = self.dom.tip.d.append('div').style('margin', '10px')

		const group_select_div = regroup_div.append('div').style('margin', '5px')

		const group_table = group_select_div.append('table').style('border-collapse', 'collapse')
		const title_tr = group_table.append('tr')

		// top title bar for the table
		title_tr
			.append('th')
			.attr('colspan', default_grp_count + 2)
			.style('padding', '2px 5px')
			.html('Groups')

		title_tr
			.append('th')
			.style('padding', '2px 5px')
			.html('Categories')

		//this row have '+'/'-' button to add new group
		const grp_btn_tr = group_table.append('tr')

		//first group cannot be deleted
		grp_btn_tr.append('th')
		grp_btn_tr.append('th')

		for (let i = 1; i < default_grp_count; i++)
			grp_btn_tr
				.append('th')
				.append('div')
				.style('padding', '2px 5px')
				.style('margin', '2px')
				.style('background-color', '#eee')
				.style('border-radius', '6px')
				.style('cursor', 'pointer')
				.html('-')
				.on('click', () => {
					for (const [key, val] of Object.entries(cat_grps)) {
						if (cat_grps[key].group == i + 1) cat_grps[key].group = 1
					}
					self.regroupMenu(default_grp_count - 1, cat_grps)
				})

		grp_btn_tr
			.append('th')
			.append('div')
			.style('padding', '2px 5px')
			.style('margin', '2px')
			.style('background-color', '#eee')
			.style('border-radius', '6px')
			.style('cursor', 'pointer')
			.html('+')
			.on('click', () => {
				self.regroupMenu(default_grp_count + 1, cat_grps)
			})

		// this row will have group names/number
		const group_name_tr = group_table.append('tr')

		group_name_tr
			.append('th')
			.style('padding', '2px 5px')
			.html('Exclude')

		for (let i = 0; i < default_grp_count; i++)
			group_name_tr
				.append('th')
				.style('padding', '2px 5px')
				.html(i + 1)

		// for each cateogry add new row with radio button for each group and category name
		for (const [key, val] of Object.entries(self.term.values)) {
			const cat_tr = group_table
				.append('tr')
				.on('mouseover', () => {
					cat_tr.style('background-color', '#eee')
				})
				.on('mouseout', () => {
					cat_tr.style('background-color', '#fff')
				})

			//checkbox for exclude group
			cat_tr
				.append('td')
				.attr('align', 'center')
				.style('padding', '2px 5px')
				.append('input')
				.attr('type', 'radio')
				.attr('name', key)
				.attr('value', 0)
				.property('checked', () => {
					if (cat_grps[key].group === 0) {
						// cat_grps[key].group = 0
						return true
					}
				})
				.on('click', () => {
					cat_grps[key].group = 0
				})

			// checkbox for each group
			for (let i = 0; i < default_grp_count; i++) {
				cat_tr
					.append('td')
					.attr('align', 'center')
					.style('padding', '2px 5px')
					.append('input')
					.attr('type', 'radio')
					.attr('name', key)
					.attr('value', i)
					.property('checked', () => {
						if (!cat_grps[key].group && cat_grps[key].group !== 0) {
							cat_grps[key].group = 1
							return true
						} else {
							return cat_grps[key].group == i + 1 ? true : false
						}
					})
					.on('click', () => {
						cat_grps[key].group = i + 1
					})
			}

			// extra empty column for '+' button
			cat_tr.append('td')

			// categories
			cat_tr
				.append('td')
				.style('display', 'inline-block')
				.style('margin', '2px')
				.style('cursor', 'default')
				.html(val.label)
		}

		const button_div = regroup_div
			.append('div')
			.style('text-align', 'center')
			.style('margin', '5px')

		// 'Apply' button
		button_div
			.append('div')
			.attr('class', 'replace_btn sja_filter_tag_btn')
			.style('display', 'inline-block')
			.style('border-radius', '10px')
			.style('background-color', '#74b9ff')
			.style('padding', '7px 6px')
			.style('margin', '5px')
			.style('text-align', 'center')
			.style('font-size', '.8em')
			.style('text-transform', 'uppercase')
			.text('Apply')
			.on('click', () => {
				//update customset and add to self.q
				for (const [key, val] of Object.entries(cat_grps)) {
					for (let i = 0; i < default_grp_count; i++) {
						if (cat_grps[key].group == i + 1) customset.groups[i].values.push({ key: key })
					}
				}
				self.q.groupsetting = {
					inuse: true,
					customset: customset
				}
				self.dom.tip.hide()
				self.opts.callback({
					id: self.term.id,
					term: self.term,
					q: self.q
				})
			})
	}

	self.showNumOpts = async function(div) {}

	self.showConditionOpts = async function(div) {}

	self.grpSet2valGrp = function(groupset) {
		const vals_with_grp = JSON.parse(JSON.stringify(self.term.values))
		for (const [i, g] of groupset.groups.entries()) {
			for (const v of g.values) {
				vals_with_grp[v.key].group = i + 1
			}
		}

		for (const [key, val] of Object.entries(vals_with_grp)) {
			if (vals_with_grp[key].group == undefined) vals_with_grp[key].group = 0
		}

		return vals_with_grp
	}
}

function termsetting_fill_q(q, term) {
	if (term.isinteger || term.isfloat) {
		/*
		if q is already initiated, do not overwrite
		to be tested if can work with partially declared state
		always copies from .bins.default
		no longer deals with the case where .bins.less is to be used as term2/0
		*/
		rx.copyMerge(q, term.bins.default)
		return
	}
	if (term.iscategorical || term.iscondition) {
		if (!q.groupsetting) q.groupsetting = {}
		if (term.groupsetting.disabled) {
			q.groupsetting.disabled = true
			return
		}
		delete q.groupsetting.disabled
		if (!('inuse' in q.groupsetting)) q.groupsetting.inuse = false // do not apply by default

		if (term.iscondition) {
			/*
			for condition term, must set up bar/value flags before quiting for inuse:false
			*/
			if (q.value_by_max_grade || q.value_by_most_recent || q.value_by_computable_grade) {
				// need any of the three to be set
			} else {
				// set a default one
				q.value_by_max_grade = true
			}
			if (q.bar_by_grade || q.bar_by_children) {
			} else {
				q.bar_by_grade = true
			}
		}

		if (!q.groupsetting.inuse) {
			// inuse:false is either from automatic setup or predefined in state
			// then no need for additional setup
			return
		}
		// if to apply the groupsetting
		if (term.groupsetting.lst && term.groupsetting.useIndex >= 0 && term.groupsetting.lst[term.groupsetting.useIndex]) {
			q.groupsetting.predefined_groupset_idx = term.groupsetting.useIndex
		}
		return
	}
	throw 'unknown term type'
}
exports.termsetting_fill_q = termsetting_fill_q
