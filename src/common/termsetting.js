import * as rx from '../common/rx.core'
import * as client from '../client'
import { appInit } from '../termdb/app'

/*

************** opts{} of constructor
.holder
.genome
.dslabel
.placeholder
.callback( data )
	.term{} // optional
	.q{}


************** this.api, exposed!!
.main( data )
	.term{} // optional
	.q{}
	.disable_terms
.showTree()


************** instance private properties
.opts{}
.term{}
.q{}
.disable_terms[]


************** introducing the atypical API
-- this.api{} is self-made, not generated by getComponentApi
-- api not registered in caller.components{}, not in the notify-cycle
-- no bus
-- upon init, termsetting constructor does not accept initial value of term/q
   term/q/disable_terms will only be set/updated through api.main()
-- termsetting opts.callback() will send caller updated term/q via user fiddling


************** explain behavior here:

*/

class TermSetting {
	constructor(opts) {
		this.opts = this.validateOpts(opts)
		this.genome = opts.genome
		this.dslabel = opts.dslabel
		this.placeholder = opts.placeholder || 'Select term&nbsp;'

		this.dom = {
			holder: opts.holder,
			tip: new client.Menu({ padding: '0px' })
		}
		setInteractivity(this)
		setRenderers(this)
		this.initUI()

		// this api will be frozen and returned by termsettingInit()
		this.api = {
			main: async (data = {}) => {
				this.validateMainData(data)
				this.term = data.term
				this.q = data.q
				this.disable_terms = data.disable_terms
				this.updateUI()
			},
			showTree: this.showTree
		}
	}

	validateOpts(o) {
		if (!o.holder) throw '.holder missing'
		if (!o.genome) throw '.genome missing'
		if (!o.dslabel) throw '.dslabel missing'
		if (typeof o.callback != 'function') throw '.callback() is not a function'
		return o
	}
	validateMainData(d) {
		if (d.term) {
			// term is optional
			if (!d.term.id) throw 'data.term.id missing'
			if (!d.term.name) throw 'data.term.name missing'
		}
		if (!d.q) d.q = {}
		if (typeof d.q != 'object') throw 'data.q{} is not object'
		if (d.disable_terms) {
			if (!Array.isArray(d.disable_terms)) throw 'data.disable_terms[] is not array'
		}
	}
}

exports.termsettingInit = rx.getInitFxn(TermSetting)

function setRenderers(self) {
	self.initUI = () => {
		// toggle the display of pilldiv and nopilldiv with availability of this.term
		self.dom.nopilldiv = self.dom.holder
			.append('div')
			.style('cursor', 'pointer')
			.on('click', self.showTree)
		self.dom.pilldiv = self.dom.holder
			.append('div')
			.attr('class', 'ts_pill')
			.style('cursor', 'pointer')
			.on('click', self.showMenu)

		// nopilldiv - placeholder label
		self.dom.nopilldiv
			.append('div')
			.html(self.placeholder)
			.style('padding', '3px 6px 3px 6px')
			.style('display', 'inline-block')

		// nopilldiv - plus button
		self.dom.nopilldiv
			.append('div')
			.attr('class', 'sja_filter_tag_btn add_term_btn')
			.style('padding', '3px 6px 3px 6px')
			.style('display', 'inline-block')
			.style('border-radius', '6px')
			.style('background-color', '#4888BF')
			.text('+')

		// blue pill, TODO add the multiple segments of a pill
		self.dom.pill_termname = self.dom.pilldiv
			.append('div')
			.style('display', 'inline-block')
			.attr('class', 'sja_filter_tag_btn ts_name_btn')
			.style('padding', '3px 6px 3px 6px')
			.style('border-radius', '6px')
			.style('background', '#4888BF')
			.style('color', 'white')
		self.dom.pill_settingSummary = self.dom.pilldiv // this may be hidden
			.append('div')
			.style('display', 'inline-block')
			.attr('class', 'sja_filter_tag_btn ts_summnary_btn')
			.style('padding', '3px 6px 3px 6px')
			.style('border-radius', '0 6px 6px 0')
			.style('background', '#674EA7')
			.style('color', 'white')
	}

	self.updateUI = () => {
		if (!self.term) {
			// no term
			self.dom.nopilldiv.style('display', 'block')
			self.dom.pilldiv.style('display', 'none')
			return
		}
		// has term
		const grpsetting_flag = self.q && self.q.groupsetting && self.q.groupsetting.inuse
		const grp_summary_text =
			self.term.groupsetting &&
			self.term.groupsetting.lst &&
			self.q.groupsetting &&
			self.q.groupsetting.predefined_groupset_idx
				? self.term.groupsetting.lst[self.q.groupsetting.predefined_groupset_idx].name
				: self.q.customset
				? 'Divided into' + self.q.customset.groups.length + 'groups'
				: ''

		self.dom.nopilldiv.style('display', 'none')
		self.dom.pilldiv.style('display', 'block')
		self.dom.pill_termname.style('border-radius', grpsetting_flag ? '6px 0 0 6px' : '6px').html(self.term.name) // TODO trim long string
		self.dom.pill_settingSummary.style('display', grpsetting_flag ? 'inline-block' : 'none')
		self.dom.pill_settingSummary.html(grp_summary_text)
	}
}

function setInteractivity(self) {
	self.removeTerm = () => {
		self.opts.callback(null)
	}

	self.showTree = () => {
		self.dom.tip.clear().showunder(self.dom.holder.node())
		appInit(null, {
			holder: self.dom.tip.d,
			state: {
				genome: self.genome,
				dslabel: self.dslabel
			},
			tree: {
				click_term: term => {
					self.dom.tip.hide()
					const data = { id: term.id, term, q: {} }
					termsetting_fill_q(data.q, term)
					self.opts.callback(data)
				},
				disable_terms: self.disable_terms
			}
		})
	}

	self.showMenu = () => {
		self.dom.tip.clear().showunder(self.dom.holder.node())

		const term_option_div = self.dom.tip.d.append('div')
		const term_edit_div = self.dom.tip.d.append('div').style('text-align', 'center')

		const optsFxn = self.term.iscategorical
			? self.showCatOpts
			: self.term.isfloat || self.term.isinteger
			? self.showNumOpts
			: self.term.iscondition
			? self.showConditionOpts
			: null

		term_option_div
			.append('div')
			.style('margin', '5px 2px')
			.style('text-align', 'center')

		optsFxn(term_option_div)

		term_edit_div
			.append('div')
			.attr('class', 'replace_btn sja_filter_tag_btn')
			.style('display', 'inline-block')
			.style('border-radius', '10px')
			.style('background-color', '#74b9ff')
			.style('padding', '7px 6px')
			.style('margin', '5px')
			.style('text-align', 'center')
			.style('font-size', '.8em')
			.style('text-transform', 'uppercase')
			.text('Replace')
			.on('click', () => {
				self.dom.tip.clear()
				self.showTree()
			})
		term_edit_div
			.append('div')
			.attr('class', 'replace_btn sja_filter_tag_btn')
			.style('display', 'inline-block')
			.style('border-radius', '10px')
			.style('background-color', '#ff7675')
			.style('padding', '7px 6px')
			.style('margin', '5px')
			.style('text-align', 'center')
			.style('font-size', '.8em')
			.style('text-transform', 'uppercase')
			.text('Remove')
			.on('click', () => {
				self.dom.tip.hide()
				self.removeTerm()
			})
	}

	self.showCatOpts = async function(div) {
		const grpsetting_flag = self.q && self.q.groupsetting && self.q.groupsetting.inuse

		const default_btn_txt =
			(grpsetting_flag ? 'Using' : 'Use') +
			' default category' +
			(self.term.values ? '(n=' + Object.keys(self.term.values).length + ')' : '')

		// default (n=total) setting btn
		const default_btn = div
			.append('div')
			.attr('class', 'group_btn sja_filter_tag_btn')
			.style('display', 'block')
			.style('padding', '7px 6px')
			.style('margin', '5px')
			.style('text-align', 'center')
			.style('font-size', '.8em')
			.style('border-radius', '10px')
			.style('background-color', grpsetting_flag ? '#f8f8f8' : '#eee')
			.style('color', '#000')
			.style('pointer-events', grpsetting_flag ? 'none' : 'auto')
			.text(default_btn_txt)

		//show button/s for default groups
		if (self.term.groupsetting && self.term.groupsetting.lst) {
			for (const group of self.term.groupsetting.lst) {
				div
					.append('div')
					.attr('class', 'group_btn sja_filter_tag_btn')
					.style('display', 'block')
					.style('padding', '7px 6px')
					.style('margin', '5px')
					.style('text-align', 'center')
					.style('font-size', '.8em')
					.style('border-radius', '10px')
					.style('background-color', '#eee')
					.style('color', '#000')
					.html('Use <b>' + group.name + '</b>')
			}
		}

		// devide to grpups btn
		const devide_btn = div
			.append('div')
			.attr('class', 'group_btn sja_filter_tag_btn')
			.style('display', 'block')
			.style('padding', '7px 6px')
			.style('margin', '5px')
			.style('text-align', 'center')
			.style('font-size', '.8em')
			.style('border-radius', '10px')
			.style('background-color', '#eee')
			.style('color', '#000')
			.html('Divide <b>' + self.term.name + '</b> to groups')
			.on('click', () => {
				self.regroupMenu()
			})

		if (self.term.groupsetting && self.term.groupsetting.disabled) devide_btn.style('display', 'none')
	}

	self.regroupMenu = function(grp_count, temp_cat_grps) {
		//start with default 2 groups, extra groups can be added by user
		const default_grp_count = grp_count || 2
		const cat_grps = temp_cat_grps || JSON.parse(JSON.stringify(self.term.values))

		//initiate empty customset
		const customset = { groups: [] }
		Array(default_grp_count)
			.fill()
			.map(() => customset.groups.push({ values: [] }))

		self.dom.tip.clear().showunder(self.dom.holder.node())

		const regroup_div = self.dom.tip.d.append('div').style('margin', '10px')

		const group_select_div = regroup_div.append('div').style('margin', '5px')

		const group_table = group_select_div.append('table').style('border-collapse', 'collapse')
		const title_tr = group_table.append('tr')

		// top title bar for the table
		title_tr
			.append('th')
			.attr('colspan', default_grp_count + 1)
			.style('padding', '2px 5px')
			.html('Groups')

		title_tr
			.append('th')
			.style('padding', '2px 5px')
			.html('Categories')

		// this row will have group names/no and '+' button to add new group
		const group_name_tr = group_table.append('tr')

		for (let i = 0; i < default_grp_count; i++)
			group_name_tr
				.append('th')
				.style('padding', '2px 5px')
				.html(i + 1)

		group_name_tr
			.append('th')
			.style('padding', '2px 5px')
			.style('margin', '2px')
			.style('background-color', '#eee')
			.style('border-radius', '6px')
			.style('cursor', 'pointer')
			.html('+')
			.on('click', () => {
				self.regroupMenu(default_grp_count + 1, cat_grps)
			})

		// for each cateogry add new row with radio button for each group and category name
		for (const [key, val] of Object.entries(self.term.values)) {
			const cat_tr = group_table
				.append('tr')
				.on('mouseover', () => {
					cat_tr.style('background-color', '#eee')
				})
				.on('mouseout', () => {
					cat_tr.style('background-color', '#fff')
				})

			// checkbox for each group
			for (let i = 0; i < default_grp_count; i++) {
				cat_tr
					.append('td')
					.attr('align', 'center')
					.style('padding', '2px 5px')
					.append('input')
					.attr('type', 'radio')
					.attr('name', key)
					.attr('value', i)
					.property('checked', () => {
						if (!cat_grps[key].group) {
							cat_grps[key].group = 1
							return true
						} else {
							return cat_grps[key].group == i + 1 ? true : false
						}
					})
					.on('click', () => {
						cat_grps[key].group = i + 1
					})
			}

			// extra empty column for '+' button
			cat_tr.append('td')

			// categories
			cat_tr
				.append('td')
				.style('display', 'inline-block')
				.style('margin', '2px')
				.style('cursor', 'default')
				.html(val.label)
		}

		const button_div = regroup_div
			.append('div')
			.style('text-align', 'center')
			.style('margin', '5px')

		// 'Apply' button
		button_div
			.append('div')
			.attr('class', 'replace_btn sja_filter_tag_btn')
			.style('display', 'inline-block')
			.style('border-radius', '10px')
			.style('background-color', '#74b9ff')
			.style('padding', '7px 6px')
			.style('margin', '5px')
			.style('text-align', 'center')
			.style('font-size', '.8em')
			.style('text-transform', 'uppercase')
			.text('Apply')
			.on('click', () => {
				//update customset and add to self.q
				for (const [key, val] of Object.entries(cat_grps)) {
					for (let i = 0; i < default_grp_count; i++) {
						if (cat_grps[key].group == i + 1) customset.groups[i].values.push(cat_grps[key])
					}
				}
				self.q.groupsetting = {
					inuse: true,
					customset: customset
				}
				self.dom.tip.hide()
			})
	}

	self.showNumOpts = async function(div) {}

	self.showConditionOpts = async function(div) {}
}

function termsetting_fill_q(q, term) {
	if (term.isinteger || term.isfloat) {
		/*
		if q is already initiated, do not overwrite
		to be tested if can work with partially declared state
		always copies from .bins.default
		no longer deals with the case where .bins.less is to be used as term2/0
		*/
		rx.copyMerge(q, term.bins.default)
		return
	}
	if (term.iscategorical || term.iscondition) {
		if (!q.groupsetting) q.groupsetting = {}
		if (term.groupsetting.disabled) {
			q.groupsetting.disabled = true
			return
		}
		delete q.groupsetting.disabled
		if (!('inuse' in q.groupsetting)) q.groupsetting.inuse = false // do not apply by default
		if (!q.groupsetting.inuse) {
			// inuse:false is either from automatic setup or predefined in state
			// then no need for additional setup
			return
		}
		if (term.groupsetting.lst && term.groupsetting.useIndex >= 0 && term.groupsetting.lst[term.groupsetting.useIndex]) {
			q.groupsetting.predefined_groupset_idx = term.groupsetting.useIndex
		}
		if (term.iscondition) {
			if (q.value_by_max_grade || q.value_by_most_recent || q.value_by_computable_grade) {
				// need any of the three to be set
			} else {
				// set a default one
				q.value_by_max_grade = true
			}
			if (q.bar_by_grade || q.bar_by_children) {
			} else {
				q.bar_by_grade = true
			}
		}
		return
	}
	throw 'unknown term type'
}
exports.termsetting_fill_q = termsetting_fill_q
