// Syntax: cd ~/proteinpaint/rust && cargo build --release && json='[{"refseq":"GATGAGAAAACGGAATCACGCCGGGCGTGGGTGGCTCATGTCTGTAATCCCAGCACTTTGGGAGGCCAACAGGAGAATGGATCACTTGAGGCCAGGAGTTCAAGACCAGCCTGGCCAACATGGTGAAACCTTGTCTCCACTGAAAAAAAAAAAAAAATTAGCTAGGTATGGTGGCATGCGCCTGTAATCCAAGCTACTCGGGAGGCTGAGGCAGGAGGTGGAGGTTGCAGTGAGCTGAGATTACGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCTGTTTCAAAAAAAAATAAAGAAAACGAAGTTTCCACACCAACCATGAGAGTGGTGATAGGAATGAAAAAGGCCACCCGACCTCCCTCTGCTGGCCTCCCCGGCAGCACGCACCTGTCTCTGCAGTTGCCTCCTCTTCTCCTCATTCTGCTCGTCCCGGGCTTGGAGATCCCTTTCGAACTGGCCCTTGAGCGCCTGCATGTTGACTTCCAGCCGCAGTTTGGCGTCCTCCGTGGCTTGCAGCTCGTCCTCCAGCTCTTCCAGCTGCGTCTTCATCTCCTCCATCTGGGTCTCCAGGGCCCGCTTGGACTTCTCCAGCTCATGGACCTGCCGGCAGAGCGGGCAGCCCCATTCTATGAGGCTCAACTTCATGAAGACGATTGAGAAACCCACCGTGAGCGGCACCTCAGGAGATCAGGGAGGTGGCTTTGGCCTCCCACAGGATGCATGGCCGGGACTCAAGATGACCCCTGAGAGTTCAGACCCCAGCCTTATCCTCGGACCCCCCAACTCAGACCCATCCTCGACTGCCATTCTCAGCCCCTCCCAGCCCCTGCACCAGTCCAAAAACCTCCTTCCATTTCCGATGATAGTTCGCTATGAAAAAGGCCAGGAGCTAGCCTCGCATGGACTGGTGAATAGCACAGAGGGTGGGCAGGCGAAACATGGACGAGAAAAACCACCCAGAGCCACTTACGTTCTTGCCCACGTCATCCTTGGAGCTGACCAGGTCTTCCATTTCGGCTTTGAGCATTTTGTTGGTCCGCTCGAGTTCCTCTTTGGCTTCCAAGGCCTCTTCAAGGGCCCGAGCCAGGGACAGGGCCTTGGTTTCCTTCTCCCTGGCTTCTGCCTCAGCTCTGTCCCTCTCATCCGCGTATTTGGAAGAGATGTTTTTCTCCTCGGCTAACAACTACAACACAAGACCCAGAGGTGACTTCTAGGCATATCCGGGGTCAGCGTCACTGAATTGTAAATACCGGGGGAAGCCCTGTGTCCTGCTGAATGTATTGAGGTGCAGGTGTAAGCAGTGTAGGTTAGCTATGGGAGTAATTTATATAATCATCTGGCGTTCTGACTTCTACATCAACCTTATGCAGAGCCAGAAATCAGCTGACTTGTTTTTTTTTGTTGGTTTGTGTGTTTGTTTGTTTTAGATGGAGTCTCACTTTGTCACCCAGGCTGGAGTGCAATGGTGCAGTCTTGGTTCACTGCAACCTCCGCCTCGTGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCAGAGTAGTTGGGATTACAGGTGCCCACCACCACACCTGGCTAATTTTTGTATTTTAAGTAGAGATGTGGTTTTGCCATGTTGACCAGGCTGGTCTCGAACTCCTGACCCTCAAGTGAGCCTCCTGCCTCGGCCTCCCAAAGCACGGAGATTACAGGTGTGAGCCACCACACCTGGCCAAATCCTTGTGCTTCGAAACCACTAGACCTGCCCACGTTGCTTAGAGCACACTGAGGTCAAAGTGAGATTTAAAGCTGCCAGAAGCTAGTTATTAGTTTGTTT", "start": 235392047, "stop": 235393047,"chr":"chr16","pos":67116400,"entries":[{"sam_info":"A00567:64:HKTFJDSXX:4:2445:10818:14121\t163\t16\t15814153\t60\t151M\t=\t15814512\t510\tGTCTCATACTCGTGAAGCTGGGCGAGGAATAGAGATGTGTGCTGCCCCACTTGCCCCTGGGAGGTCCTTTGGCTCACCTAGGCAGCACATCACTGCACCCCTTCCCCAGCACAGCCCCCTTGTGAGGTGGGCATCTCATCCCCAGTTGCAG\tFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFF:FFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFF:FFFFFFF:FF\tX0:i:1\tX1:i:0\tMD:Z:151\tPG:Z:MarkDuplicates\tRG:Z:r1626484\tXG:i:0\tAM:i:37\tNM:i:0\tSM:i:37\tXM:i:0\tXO:i:0\tXT:A:U","tempscore":"","ridx":0},{"sam_info":"A00647:38:HL3LGDSXX:1:2463:15076:9846\t99\t16\t15814153\t60\t151M\t=\t15814386\t384\tGTCTCATACTCGTGAAGCTGGGCGAGGAATAGAGATGTGTGCTGCCCCACTTGCCCCTGGGAGGTCCTTTGGCTCACCTAGGCAGCACATCACTGCACCCCTTCCCCAGCACAGCCCCCTTGTGAGGTGGGCATCTCATCCCCAGTTGCAG\tFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFF,FFFFFFFFFFFF\tX0:i:1\tX1:i:0\tMD:Z:151\tPG:Z:MarkDuplicates\tRG:Z:r1626506\tXG:i:0\tAM:i:37\tNM:i:0\tSM:i:37\tXM:i:0\tXO:i:0\tXT:A:U","tempscore":"","ridx":0},{"sam_info":"A00647:38:HL3LGDSXX:2:1401:7166:23171\t99\t16\t15814157\t60\t151M\t=\t15814297\t291\tCATACTCGTGAAGCTGGGCGAGGAATAGAGATGTGTGCTGCCCCACTTGCCCCTGGGAGGTCCTTTGGCTCACCTAGGCAGCACATCACTGCACCCCTTCCCCAGCACAGCCCCCTTGTGAGGTGGGCATCTCATCCCCAGTTGCAGATGA\tFFFFF:FFFFFFFFFFFFFFFFFFFFFFF::FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFF\tX0:i:1\tX1:i:0\tMD:Z:151\tPG:Z:MarkDuplicates\tRG:Z:r1626508\tXG:i:0\tAM:i:37\tNM:i:0\tSM:i:37\tXM:i:0\tXO:i:0\tXT:A:U","tempscore":"","ridx":0}]}, {"refseq":"GATGAGAAAACGGAATCACGCCGGGCGTGGGTGGCTCATGTCTGTAATCCCAGCACTTTGGGAGGCCAACAGGAGAATGGATCACTTGAGGCCAGGAGTTCAAGACCAGCCTGGCCAACATGGTGAAACCTTGTCTCCACTGAAAAAAAAAAAAAAATTAGCTAGGTATGGTGGCATGCGCCTGTAATCCAAGCTACTCGGGAGGCTGAGGCAGGAGGTGGAGGTTGCAGTGAGCTGAGATTACGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCTGTTTCAAAAAAAAATAAAGAAAACGAAGTTTCCACACCAACCATGAGAGTGGTGATAGGAATGAAAAAGGCCACCCGACCTCCCTCTGCTGGCCTCCCCGGCAGCACGCACCTGTCTCTGCAGTTGCCTCCTCTTCTCCTCATTCTGCTCGTCCCGGGCTTGGAGATCCCTTTCGAACTGGCCCTTGAGCGCCTGCATGTTGACTTCCAGCCGCAGTTTGGCGTCCTCCGTGGCTTGCAGCTCGTCCTCCAGCTCTTCCAGCTGCGTCTTCATCTCCTCCATCTGGGTCTCCAGGGCCCGCTTGGACTTCTCCAGCTCATGGACCTGCCGGCAGAGCGGGCAGCCCCATTCTATGAGGCTCAACTTCATGAAGACGATTGAGAAACCCACCGTGAGCGGCACCTCAGGAGATCAGGGAGGTGGCTTTGGCCTCCCACAGGATGCATGGCCGGGACTCAAGATGACCCCTGAGAGTTCAGACCCCAGCCTTATCCTCGGACCCCCCAACTCAGACCCATCCTCGACTGCCATTCTCAGCCCCTCCCAGCCCCTGCACCAGTCCAAAAACCTCCTTCCATTTCCGATGATAGTTCGCTATGAAAAAGGCCAGGAGCTAGCCTCGCATGGACTGGTGAATAGCACAGAGGGTGGGCAGGCGAAACATGGACGAGAAAAACCACCCAGAGCCACTTACGTTCTTGCCCACGTCATCCTTGGAGCTGACCAGGTCTTCCATTTCGGCTTTGAGCATTTTGTTGGTCCGCTCGAGTTCCTCTTTGGCTTCCAAGGCCTCTTCAAGGGCCCGAGCCAGGGACAGGGCCTTGGTTTCCTTCTCCCTGGCTTCTGCCTCAGCTCTGTCCCTCTCATCCGCGTATTTGGAAGAGATGTTTTTCTCCTCGGCTAACAACTACAACACAAGACCCAGAGGTGACTTCTAGGCATATCCGGGGTCAGCGTCACTGAATTGTAAATACCGGGGGAAGCCCTGTGTCCTGCTGAATGTATTGAGGTGCAGGTGTAAGCAGTGTAGGTTAGCTATGGGAGTAATTTATATAATCATCTGGCGTTCTGACTTCTACATCAACCTTATGCAGAGCCAGAAATCAGCTGACTTGTTTTTTTTTGTTGGTTTGTGTGTTTGTTTGTTTTAGATGGAGTCTCACTTTGTCACCCAGGCTGGAGTGCAATGGTGCAGTCTTGGTTCACTGCAACCTCCGCCTCGTGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCAGAGTAGTTGGGATTACAGGTGCCCACCACCACACCTGGCTAATTTTTGTATTTTAAGTAGAGATGTGGTTTTGCCATGTTGACCAGGCTGGTCTCGAACTCCTGACCCTCAAGTGAGCCTCCTGCCTCGGCCTCCCAAAGCACGGAGATTACAGGTGTGAGCCACCACACCTGGCCAAATCCTTGTGCTTCGAAACCACTAGACCTGCCCACGTTGCTTAGAGCACACTGAGGTCAAAGTGAGATTTAAAGCTGCCAGAAGCTAGTTATTAGTTTGTTT","start": 235657639,"stop":235658639,"chr":"chr16","pos":15814303,"entries":[{"sam_info":"A00567:64:HKTFJDSXX:4:2445:10818:14121\t163\t16\t15814153\t60\t151M\t=\t15814512\t510\tGTCTCATACTCGTGAAGCTGGGCGAGGAATAGAGATGTGTGCTGCCCCACTTGCCCCTGGGAGGTCCTTTGGCTCACCTAGGCAGCACATCACTGCACCCCTTCCCCAGCACAGCCCCCTTGTGAGGTGGGCATCTCATCCCCAGTTGCAG\tFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFF:FFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFF:FFFFFFF:FF\tX0:i:1\tX1:i:0\tMD:Z:151\tPG:Z:MarkDuplicates\tRG:Z:r1626484\tXG:i:0\tAM:i:37\tNM:i:0\tSM:i:37\tXM:i:0\tXO:i:0\tXT:A:U","tempscore":"","ridx":0},{"sam_info":"A00647:38:HL3LGDSXX:1:2463:15076:9846\t99\t16\t15814153\t60\t151M\t=\t15814386\t384\tGTCTCATACTCGTGAAGCTGGGCGAGGAATAGAGATGTGTGCTGCCCCACTTGCCCCTGGGAGGTCCTTTGGCTCACCTAGGCAGCACATCACTGCACCCCTTCCCCAGCACAGCCCCCTTGTGAGGTGGGCATCTCATCCCCAGTTGCAG\tFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFF,FFFFFFFFFFFF\tX0:i:1\tX1:i:0\tMD:Z:151\tPG:Z:MarkDuplicates\tRG:Z:r1626506\tXG:i:0\tAM:i:37\tNM:i:0\tSM:i:37\tXM:i:0\tXO:i:0\tXT:A:U","tempscore":"","ridx":0},{"sam_info":"A00647:38:HL3LGDSXX:2:1401:7166:23171\t99\t16\t15814157\t60\t151M\t=\t15814297\t291\tCATACTCGTGAAGCTGGGCGAGGAATAGAGATGTGTGCTGCCCCACTTGCCCCTGGGAGGTCCTTTGGCTCACCTAGGCAGCACATCACTGCACCCCTTCCCCAGCACAGCCCCCTTGTGAGGTGGGCATCTCATCCCCAGTTGCAGATGA\tFFFFF:FFFFFFFFFFFFFFFFFFFFFFF::FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:FFFFFFFFFFF\tX0:i:1\tX1:i:0\tMD:Z:151\tPG:Z:MarkDuplicates\tRG:Z:r1626508\tXG:i:0\tAM:i:37\tNM:i:0\tSM:i:37\tXM:i:0\tXO:i:0\tXT:A:U","tempscore":"","ridx":0}]}]' && time echo "$json" | target/release/sv

use json::JsonValue;
use serde::{Deserialize, Serialize};
use serde_json;
//use std::cmp::Ordering;
pub mod realign;
use std::io; // Import functions from realign.rs

#[derive(Debug, Serialize, Deserialize)]
struct ReadInfo {
    qname: String,
    seq: String,
    cigar: String,
    start_position: i64,
    flag: i64,
    ridx: usize,
    sam_info: String,
}

// A separate struct has been created from ReadInfo so as to minimize amount of data piped out of the Rust script
#[derive(Debug, Serialize, Deserialize)]
struct OutputReadInfo {
    sam_info: String,
    ridx: usize,
}

fn main() {
    let mut input = String::new();
    match io::stdin().read_line(&mut input) {
        // Accepting the piped input from nodejs (or command line from testing)
        #[allow(unused_variables)]
        Ok(n) => {
            //println!("{} bytes read", n);
            //println!("{}", input);
        }
        Err(error) => println!("Piping error: {}", error),
    }

    let input_json = json::parse(&input);

    match input_json {
        Ok(json_string) => {
            //println!("Input json:{}", json_string);

            // Assuming there are only two regions for now
            let region1 = &json_string[0];
            let region2 = &json_string[1];
            let _refseq_region1: String = json_string[0]["refseq"].as_str().unwrap().to_string();
            //println!("region1:{}", region1);
            let _refseq_region2: String = json_string[1]["refseq"].as_str().unwrap().to_string();
            //println!("region2:{}", region2);
            let _chr_region1: String = json_string[0]["chr"].as_str().unwrap().to_string();
            let _chr_region2: String = json_string[1]["chr"].as_str().unwrap().to_string();
            let start_region1: i64 = json_string[0]["start"].as_i64().unwrap();
            let stop_region1: i64 = json_string[0]["stop"].as_i64().unwrap();
            let _start_region2: i64 = json_string[1]["start"].as_i64().unwrap();
            let _stop_region2: i64 = json_string[1]["stop"].as_i64().unwrap();
            let mut pos_region1: i64 = json_string[0]["pos"].as_i64().unwrap();
            let mut pos_region2: i64 = json_string[1]["pos"].as_i64().unwrap();
            //println!("pos_region1:{}", pos_region1);
            //println!("pos_region2:{}", pos_region2);

            // Check if pos_region1 lies between start_region1 and stop_region1. If not exchange values between pos_region1 and pos_region1
            if start_region1 <= pos_region1 && pos_region1 <= stop_region1 {
            } else {
                let temp_pos: i64 = pos_region1;
                pos_region1 = pos_region2;
                pos_region2 = temp_pos;
            }

            let reads_region1: &JsonValue = &region1["entries"]; // Parsing each region separately
            let reads_region2: &JsonValue = &region2["entries"]; // Parsing each region separately

            // Select only those reads that contain the break-point of the SV/fusion

            let (reads1_overlap, reads1_output) =
                check_read_containing_break_point(reads_region1, pos_region1, 0);
            let (reads2_overlap, reads2_output) =
                check_read_containing_break_point(reads_region2, pos_region2, 1);

            //println!("reads1_overlap length:{}", reads1_overlap.len());
            //println!("reads2_overlap length:{}", reads2_overlap.len());

            let mut reads1 = Vec::<ReadInfo>::new();
            for i in 0..reads_region1.len() {
                let read_temp: String = reads_region1[i]["sam_info"].as_str().unwrap().to_string();
                //println!("read_temp:{:?}", read_temp);
                let args: Vec<&str> = read_temp.split('\t').collect();
                reads1.push(ReadInfo {
                    qname: args[0].parse::<String>().unwrap(),
                    seq: args[9].parse::<String>().unwrap(),
                    cigar: args[5].parse::<String>().unwrap(),
                    start_position: args[3].parse::<i64>().unwrap(),
                    flag: args[1].parse::<i64>().unwrap(),
                    ridx: 0,
                    sam_info: read_temp,
                })
            }

            let mut reads2 = Vec::<ReadInfo>::new();
            for i in 0..reads_region2.len() {
                let read_temp: String = reads_region2[i]["sam_info"].as_str().unwrap().to_string();
                //println!("read_temp:{:?}", read_temp);
                let args: Vec<&str> = read_temp.split('\t').collect();
                reads2.push(ReadInfo {
                    qname: args[0].parse::<String>().unwrap(),
                    seq: args[9].parse::<String>().unwrap(),
                    cigar: args[5].parse::<String>().unwrap(),
                    start_position: args[3].parse::<i64>().unwrap(),
                    flag: args[1].parse::<i64>().unwrap(),
                    ridx: 1,
                    sam_info: read_temp,
                })
            }
            //println!("reads1:{}", reads1.len());
            //println!("reads2:{}", reads2.len());

            let mut multi_region_templates: String = "[".to_string();
            let mut single_region_templates: String = "[".to_string();
            let mut multi_region_templates_list = Vec::<String>::new();
            for i in 0..reads1.len() {
                for j in 0..reads2.len() {
                    if reads1[i].qname == reads2[j].qname {
                        multi_region_templates += &serde_json::to_string(&OutputReadInfo {
                            sam_info: reads1[i].sam_info.clone(),
                            ridx: 0,
                        })
                        .unwrap();
                        multi_region_templates += &",".to_string();
                        multi_region_templates += &serde_json::to_string(&OutputReadInfo {
                            sam_info: reads2[j].sam_info.clone(),
                            ridx: 1,
                        })
                        .unwrap();
                        multi_region_templates += &",".to_string();
                        multi_region_templates_list.push(reads1[i].qname.clone());
                        break;
                    }
                }
            }

            // Putting all reads(templates) that contain SV/fusion break points but are not in multiple regions into single_region_templates
            for i in 0..reads1_overlap.len() {
                let mut hit = 0;
                for j in 0..multi_region_templates_list.len() {
                    if reads1_overlap[i].qname == multi_region_templates_list[j] {
                        hit = 1;
                        break;
                    }
                }
                if hit == 0 {
                    single_region_templates += &serde_json::to_string(&reads1_output[i]).unwrap();
                    //single_region_templates += &reads1_overlap[i].qname;
                    single_region_templates += &",".to_string();
                }
            }
            for i in 0..reads2_overlap.len() {
                let mut hit = 0;
                for j in 0..multi_region_templates_list.len() {
                    if reads2_overlap[i].qname == multi_region_templates_list[j] {
                        hit = 1;
                        break;
                    }
                }
                if hit == 0 {
                    single_region_templates += &serde_json::to_string(&reads2_output[i]).unwrap();
                    //single_region_templates += &reads2_overlap[i].qname;
                    single_region_templates += &",".to_string();
                }
            }
            if single_region_templates != "[" {
                single_region_templates.pop(); // Removing the last "," character from string
            }
            single_region_templates += &"]".to_string();
            if multi_region_templates != "[" {
                multi_region_templates.pop(); // Removing the last "," character from string
            }
            multi_region_templates += &"]".to_string();

            println!("single_region_templates:{}", single_region_templates);
            println!("multi_region_templates:{}", multi_region_templates);
        }
        Err(error) => println!("Incorrect json: {}", error),
    }
}

fn check_read_containing_break_point(
    reads_region: &JsonValue,
    pos_region: i64,
    ridx: usize,
) -> (Vec<ReadInfo>, Vec<OutputReadInfo>) {
    //println!("reads_region:{}", reads_region);
    let mut reads = Vec::<ReadInfo>::new();
    let mut reads_output = Vec::<OutputReadInfo>::new();
    for j in 0..reads_region.len() {
        let read_temp: String = reads_region[j]["sam_info"].as_str().unwrap().to_string();
        //println!("read_temp:{:?}", read_temp);
        let args: Vec<&str> = read_temp.split('\t').collect();
        let cigar_sequence: String = args[5].parse::<String>().unwrap();
        let read_sequence: String = args[9].parse::<String>().unwrap();
        if &cigar_sequence == &"*" || &cigar_sequence == &"=" {
        } else {
            let mut correct_start_position = args[3].parse::<i64>().unwrap();
            let mut correct_end_position = correct_start_position; // Correct end position of read
            let mut splice_freq: usize = 0; // Number of times the read has been spliced

            //println!("cigar_sequence:{}", cigar_sequence);
            let (alphabets, numbers) = realign::parse_cigar(&cigar_sequence);
            if &alphabets[0].to_string().as_str() == &"I"
                || &alphabets[0].to_string().as_str() == &"S"
            {
                correct_start_position =
                    correct_start_position - numbers[0].to_string().parse::<i64>().unwrap();
                // Correcting for incorrect left position (when read starts with a softclip) by subtracting length of softclip from original left most position of read
            }

            for i in 0..alphabets.len() {
                //if &alphabets[i].to_string().as_str() == &"D" {
                //    // In case of deleted nucleotides, the end position will be pushed to the left
                //    correct_end_position += numbers[i].to_string().parse::<i64>().unwrap();
                //} else
                if &alphabets[i].to_string().as_str() == &"H" { // In case of a hard-clip, the read in the bam file will not contain indel region
                } else if &alphabets[i].to_string().as_str() == &"N" {
                    splice_freq += 1;
                    correct_end_position += numbers[i].to_string().parse::<i64>().unwrap();
                } else if &alphabets[i].to_string().as_str() == &"I" {
                } else {
                    correct_end_position += numbers[i].to_string().parse::<i64>().unwrap();
                }
            }

            //println!("qname:{}", args[0].parse::<String>().unwrap());
            //println!("cigar:{}", cigar_sequence);
            //println!(
            //    "original_start_position:{}",
            //    args[3].parse::<i64>().unwrap()
            //);
            //println!("correct_start_position:{}", correct_start_position);
            //println!("correct_end_position:{}", correct_end_position);
            //println!("pos_region:{}", pos_region);

            if splice_freq == 0 {
                if correct_start_position <= pos_region && pos_region <= correct_end_position {
                    // Parsing out all the alphabets and numbers from the cigar sequence (using parse_cigar function)
                    //println!("Contains break point");
                    reads.push(ReadInfo {
                        qname: args[0].parse::<String>().unwrap(),
                        seq: read_sequence,
                        cigar: args[5].parse::<String>().unwrap(),
                        start_position: args[3].parse::<i64>().unwrap(),
                        flag: args[1].parse::<i64>().unwrap(),
                        ridx: ridx,
                        sam_info: read_temp.clone(),
                    });
                    reads_output.push(OutputReadInfo {
                        sam_info: read_temp,
                        ridx: ridx,
                    })
                }
            //else {
            //    println!("No");
            //}
            } else {
                let mut splice_start_frag = correct_start_position; // Start of spliced part of read which contains indel region in ref genome coordinates
                let mut splice_stop_frag = correct_start_position; // Stop of spliced part of read which contains indel region in ref genome coordinates
                let mut new_frag = 1; // Flag indicating start of a new fragment after splicing
                let mut nucleotide_position_without_splicing = 0; // This contains the position of nucleotide being analyzed w.r.t to read without splicing
                let mut nucleotide_position_wrt_genome = correct_start_position; // This contains the position of nucleotide being analyzed w.r.t to genome
                let mut splice_start_pos: i64 = 0; // Start position of the spliced part of the region containing indel site relative to the read
                let mut splice_stop_pos: i64 = 0; // Stop position of the spliced part of the region containing indel site relative to the read
                let mut contains_break_point = false;
                for i in 0..alphabets.len() {
                    if new_frag == 1 {
                        //splice_start_frag = nucleotide_position_wrt_genome;
                        splice_start_frag = nucleotide_position_wrt_genome;
                        splice_stop_frag = splice_start_frag;
                        splice_start_pos = nucleotide_position_without_splicing;
                        splice_stop_pos = nucleotide_position_without_splicing;
                        new_frag = 0
                    }

                    if &alphabets[i].to_string().as_str() != &"N" {
                        nucleotide_position_without_splicing +=
                            numbers[i].to_string().parse::<i64>().unwrap();
                    }

                    if &alphabets[i].to_string().as_str() == &"N" {
                        nucleotide_position_wrt_genome +=
                            numbers[i].to_string().parse::<i64>().unwrap();
                    } else if &alphabets[i].to_string().as_str() == &"I" {
                        // In case of an insertion, the position w.r.t to read will change, but no change will occur w.r.t reference genome since the inserted nucleotides are not present in the reference genome
                        splice_stop_pos += numbers[i].to_string().parse::<i64>().unwrap();
                    } else if &alphabets[i].to_string().as_str() == &"D" {
                        // In case of a deletion, the position w.r.t reference genome will change but no change will occur w.r.t reads since the deleted nucleotides are not present in the read
                        splice_stop_frag += numbers[i].to_string().parse::<i64>().unwrap();
                        nucleotide_position_wrt_genome +=
                            numbers[i].to_string().parse::<i64>().unwrap();
                    } else if &alphabets[i].to_string().as_str() == &"M"
                        || &alphabets[i].to_string().as_str() == &"S"
                    {
                        splice_stop_frag += numbers[i].to_string().parse::<i64>().unwrap();
                        splice_stop_pos += numbers[i].to_string().parse::<i64>().unwrap();
                        nucleotide_position_wrt_genome +=
                            numbers[i].to_string().parse::<i64>().unwrap();
                    }

                    //println!(
                    //    "nucleotide_position_wrt_genome:{}",
                    //    nucleotide_position_wrt_genome
                    //);
                    //println!("alphabet:{}", &alphabets[i].to_string().as_str());
                    //println!("splice_start_frag:{}", splice_start_frag);
                    //println!("splice_stop_frag:{}", splice_stop_frag);

                    if &alphabets[i].to_string().as_str() == &"N" {
                        new_frag = 1;
                        //splice_stop_frag += numbers[i].to_string().parse::<i64>().unwrap();
                        // Check if this fragment of read contains indel region or not
                        if splice_start_frag <= pos_region && pos_region <= splice_stop_frag {
                            //correct_start_position = splice_start_frag;
                            //correct_end_position = splice_stop_frag;
                            //splice_start_pos = splice_start_frag;
                            //splice_stop_pos = nucleotide_position_without_splicing;
                            contains_break_point = true;
                            break;
                        }
                        //splice_stop_frag -= numbers[i].to_string().parse::<i64>().unwrap();
                    } else if i == alphabets.len() - 1 {
                        // Last entry in CIGAR
                        // Check if this fragment of read contains indel region or not
                        if splice_start_frag <= pos_region && pos_region <= splice_stop_frag {
                            //correct_start_position = splice_start_frag;
                            //correct_end_position = splice_stop_frag;
                            //splice_start_pos = splice_start_frag;
                            //splice_stop_pos = nucleotide_position_without_splicing;
                            //println!("splice_stop_frag:{}", splice_stop_frag);
                            contains_break_point = true;
                            break;
                        } else {
                            //println!("Somehow fragment containing indel site was not found, please check (within_indel = 0)!");
                            //within_indel = 0;
                            //println!("splice_start_frag:{}", splice_start_frag);
                            //println!("splice_stop_frag2:{}", splice_stop_frag);
                            //println!("indel_start:{}", indel_start);
                            //println!("indel_stop:{}", indel_start + indel_length as i64);
                        }
                    }
                }

                if contains_break_point == true {
                    //println!("Contains break point");
                    let mut final_sequence = String::new(); // Contains spliced sequences which overlaps with indel region. If read not spliced, contains entire sequence
                    let sequence_vector: Vec<_> = read_sequence.chars().collect(); // Vector containing each sequence nucleotides as separate elements in the vector

                    //println!("splice_start_pos:{}", splice_start_pos);
                    //println!("splice_stop_pos:{}", splice_stop_pos);
                    for k in splice_start_pos..splice_stop_pos {
                        if (k as usize) < sequence_vector.len() {
                            final_sequence += &sequence_vector[k as usize].to_string();
                        }
                    }

                    // Parsing out all the alphabets and numbers from the cigar sequence (using parse_cigar function)
                    reads.push(ReadInfo {
                        qname: args[0].parse::<String>().unwrap(),
                        seq: final_sequence,
                        cigar: args[5].parse::<String>().unwrap(),
                        start_position: args[3].parse::<i64>().unwrap(),
                        flag: args[1].parse::<i64>().unwrap(),
                        ridx: ridx,
                        sam_info: read_temp.clone(),
                    });
                    reads_output.push(OutputReadInfo {
                        sam_info: read_temp,
                        ridx: ridx,
                    })
                }
            }
        }
    }
    //println!("reads:{:?}", reads);
    (reads, reads_output)
}
